var ldap = require('ldapjs');
var async = require('async');
var _ = require('underscore');

var RangeRetrievalSpecifierAttribute = require('./rangeretrievalspecifierattribute');

var dn = require('./distinguishedname');
var filter = require('./filter');
var referral = require('./referral');
var inspector = require('./inspector');

var defaultPageSize = 1000; // The maximum number of results that AD will return in a single call. Default=1000


function Client(opts) {
  if (! (this instanceof Client)) return(new Client(opts));


}

/**
 * Factory to create the LDAP client object.
 *
 * @private
 * @param {String} [url] The url to use when creating the LDAP client.
 */
function createClient(url) {
  // Attempt to get Url from this instance.
  url = url || this.url || (this.ldapOpts || {}).url;
  if (! url) {
    throw 'No url specified for ActiveDirectory client.';
  }
  log.trace('createClient(%s)', url);

  var opts = _.defaults({}, { url: url }, this.ldapOpts);
  log.debug('Creating ldapjs client for %s. Opts: %j', opts.url, _.omit(opts, 'url', 'bindDN', 'bindCredentials'));
  var client = ldap.createClient(opts);
  return(client);
}

/**
 * Checks to see if the specified referral or "chase" is allowed.
 * @param {String} referral The referral to inspect.
 * @returns {Boolean} True if the referral should be followed, false if otherwise.
 */
function isAllowedReferral(referral) {
  log.trace('isAllowedReferral(%j)', referral);
  if (! defaultReferrals.enabled) return(false);
  if (! referral) return(false);

  return(! _.any(defaultReferrals.exclude, function(exclusion) {
    var re = new RegExp(exclusion, "i");
    return(re.test(referral));
  }));
}

/**
 * Performs a search on the LDAP tree.
 *
 * @private
 * @param {String} [baseDN] The optional base directory where the LDAP query is to originate from. If not specified, then starts at the root.
 * @param {Object} [opts] LDAP query string parameters to execute. { scope: '', filter: '', attributes: [ '', '', ... ], sizeLimit: 0, timelimit: 0 }
 * @param {Function} callback The callback to execure when completed. callback(err: {Object}, results: {Array[Object]}})
 */
function search(baseDN, opts, callback) {
  var self = this;

  if (typeof(opts) === 'function') {
    callback = opts;
    opts = baseDN;
    baseDN = undefined;
  }
  if (typeof(baseDN) === 'object') {
    opts = baseDN;
    baseDN = undefined;
  }
  baseDN || (baseDN = self.baseDN);
  log.trace('search(%s,%j)', baseDN, opts);

  var isDone = false;
  var pendingReferrals = [];
  var pendingRangeRetrievals = 0;
  var client = createClient.call(self);
  client.on('error', function(err) {
    log.error(err, '[%s] An error occurred performing the requested LDAP search on %s (%j)',
        (err || {}).errno || 'UNKNOWN', baseDN, opts);
    // Ignore ECONNRESET errors
    if ((err || {}).errno !== 'ECONNRESET') {
      self.emit('error', err);
    }
  });

  /**
   * Call to remove the specified referral client.
   * @param {Object} client The referral client to remove.
   */
  function removeReferral(client) {
    if (! client) return;

    client.unbind();
    var indexOf = pendingReferrals.indexOf(client);
    if (indexOf >= 0) {
      pendingReferrals.splice(indexOf, 1);
    }
  }

  /**
   * Occurs when a search entry is received. Cleans up the search entry and pushes it to the result set.
   * @param {Object} entry The entry received.
   */
  function onSearchEntry(entry) {
    log.trace('onSearchEntry(%j)', entry);
    var result = entry.object;
    delete result.controls; // Remove the controls array returned as part of the SearchEntry

    // Some attributes can have range attributes (paging). Execute the query
    // again to get additional items.
    pendingRangeRetrievals++;
    parseRangeAttributes.call(self, result, opts, function(err, item) {
      pendingRangeRetrievals--;

      // On error, use the original result.
      if (err) item = result;
      results.push(item);

      if ((! pendingRangeRetrievals) && (isDone)) {
        onSearchEnd(item);
      }
    });
  }

  /**
   * Occurs when a search reference / referral is received. Follows the referral chase if
   * enabled.
   * @param {Object} ref The referral.
   */
  function onReferralChase(ref) {
    var index = 0;
    var referralUrl;
    // Loop over the referrals received.
    while (referralUrl = (ref.uris || [])[index++]) {
      if (isAllowedReferral(referralUrl)) {
        log.debug('Following LDAP referral chase at %s', referralUrl);
        var referralClient = createClient.call(self, referralUrl);
        pendingReferrals.push(referralClient);

        referralClient.search(referralClient.url.DN, opts, function(err, res) {
          /**
           * Occurs when a error is encountered with the referral client.
           * @param {Object} err The error object or string.
           */
          function onReferralError(err) {
            log.error(err, '[%s] An error occurred chasing the LDAP referral on %s (%j)',
              (err || {}).errno, referralClient.url.DN, opts);
            removeReferral(referralClient);
          }
          // If the referral chase / search failed, fail silently.
          if (err) {
            onReferralError(err);
            return;
          }

          res.on('searchEntry', onSearchEntry);
          res.on('searchReference', onReferralChase);
          res.on('error', onReferralError);
          res.on('end', function(result) {
            removeReferral(referralClient);
            onSearchEnd(result);
          });
        });
      }
    }
  }

  /**
   * Occurs when a search error occurs.
   * @param {Object} err The error object or string.
   */
  function onSearchError(err) {
    log.error(err, '[%s] An error occurred performing the requested LDAP search on %s (%j)',
      (err || {}).errno, baseDN, opts);
    self.emit('error', err);
    if (callback) callback(err);
  }

  /**
   * Occurs when a search results have all been processed.
   * @param {Object} result
   */
  function onSearchEnd(result) {
    if ((! pendingRangeRetrievals) && (pendingReferrals.length <= 0)) {
      client.unbind();
      log.info('Active directory search (%s) for "%s" returned %d entries.',
        baseDN, string.ellipsis(opts.filter),
        (results || []).length);
      if (callback) callback(null, results);
    }
  }

  var results = [];

  var controls = [];
  controls.push(new ldap.PagedResultsControl({ value: { size: defaultPageSize } }));
  log.debug('Querying active directory (%s) with filter "%s" for %j',
    baseDN, string.ellipsis(opts.filter),
    _.any(opts.attributes) ? opts.attributes : '[*]');
  client.search(baseDN, opts, controls, function(err, res) {
    if (err) {
      if (callback) callback(err);
      return;
    }

    res.on('searchEntry', onSearchEntry);
    res.on('searchReference', onReferralChase);
    res.on('error', onSearchError);
    res.on('end', function(result) {
      isDone = true; // Flag that the primary query is complete
      onSearchEnd(result);
    });
  });
}

/**
 * Handles any attributes that might have been returned with a range= specifier.
 *
 * @private
 * @param {Object} result The entry returned from the query.
 * @param {Object} opts The original LDAP query string parameters to execute. { scope: '', filter: '', attributes: [ '', '', ... ], sizeLimit: 0, timelimit: 0 }
 * @param {Function} callback The callback to execute when completed. callback(err: {Object}, result: {Object}})
 */
function parseRangeAttributes(result, opts, callback) {
  log.trace('parseRangeAttributes(%j,%j)', result, opts);
  var self = this;

  // Check to see if any of the result attributes have range= attributes.
  // If not, return immediately.
  if (! RangeRetrievalSpecifierAttribute.prototype.hasRangeAttributes(result)) {
    callback(null, result);
    return;
  }

  // Parse the range attributes that were provided. If the range attributes are null
  // or indicate that the range is complete, return the result.
  var rangeAttributes = RangeRetrievalSpecifierAttribute.prototype.getRangeAttributes(result);
  if ((! rangeAttributes) || (rangeAttributes.length <= 0)) {
    callback(null, result);
    return;
  }

  // Parse each of the range attributes. Merge the range attributes into
  // the properly named property.
  var queryAttributes = [];
  _.each(rangeAttributes, function(rangeAttribute, index) {
    // Merge existing range into the properly named property.
    if (! result[rangeAttribute.attributeName]) result[rangeAttribute.attributeName] = [];
    Array.prototype.push.apply(result[rangeAttribute.attributeName], result[rangeAttribute.toString()]);
    delete(result[rangeAttribute.toString()]);

    // Build our ldap query attributes with the proper attribute;range= tags to
    // get the next sequence of data.
    var queryAttribute = rangeAttribute.next();
    if ((queryAttribute) && (! queryAttribute.isComplete())) {
      queryAttributes.push(queryAttribute.toString());
    }
  });

  // If we're at the end of the range (i.e. all items retrieved), return the result.
  if (queryAttributes.length <= 0) {
    log.debug('All attribute ranges %j retrieved for %s', rangeAttributes, result.dn);
    callback(null, result);
    return;
  }

  log.debug('Attribute range retrieval specifiers %j found for "%s". Next range: %j',
    rangeAttributes, result.dn, queryAttributes);
  // Execute the query again with the query attributes updated.
  opts = _.defaults({ filter: '(distinguishedName='+dn.parseDistinguishedName(result.dn)+')',
    attributes: queryAttributes }, opts);
  search.call(self, opts, function onSearch(err, results) {
    if (err) {
      callback(err);
      return;
    }

    // Should be only one result
    var item = (results || [])[0];
    for(var property in item) {
      if (item.hasOwnProperty(property)) {
        if (! result[property]) result[property] = [];
        if (_.isArray(result[property])) {
          Array.prototype.push.apply(result[property], item[property]);
        }
      }
    }
    callback(null, result);
  });
}

/**
 * Gets all of the groups that the specified distinguishedName (DN) belongs to.
 *
 * @private
 * @param {Object} [opts] Optional LDAP query string parameters to execute. { scope: '', filter: '', attributes: [ '', '', ... ], sizeLimit: 0, timelimit: 0 }
 * @param {String} dn The distinguishedName (DN) to find membership of.
 * @param {Function} callback The callback to execute when completed. callback(err: {Object}, groups: {Array[Group]})
 */
function getGroupMembershipForDN(opts, distinguishedName, stack, callback) {
  var self = this;

  if (typeof(stack) === 'function') {
    callback = stack;
    stack = undefined;
  }
  if (typeof(distinguishedName) === 'function') {
    callback = distinguishedName;
    distinguishedName = opts;
    opts = undefined;
  }
  if (typeof(opts) === 'string') {
    stack = distinguishedName;
    distinguishedName = opts;
    opts = undefined;
  }
  log.trace('getGroupMembershipForDN(%j,%s,%j)', opts, distinguishedName, stack);

  // Ensure that a valid DN was provided. Otherwise abort the search.
  if (! distinguishedName) {
    var error = new Error('No distinguishedName (dn) specified for group membership retrieval.');
    log.error(error);
    self.emit('error', error);
    callback(error);
    return;
  }

  //  Note: Microsoft provides a 'Transitive Filter' for querying nested groups.
  //        i.e. (member:1.2.840.113556.1.4.1941:=<userDistinguishedName>)
  //        However this filter is EXTREMELY slow. Recursively querying ActiveDirectory
  //        is typically 10x faster.
  var opts = _.defaults(opts || {}, {
    filter: '(member='+dn.parseDistinguishedName(distinguishedName)+')',
    scope: 'sub',
    attributes: [ 'objectCategory', 'groupType', 'distinguishedName', 'cn' ]
  });
  search.call(self, opts, function(err, results) {
    if (err) {
      callback(err);
      return;
    }

    var groups = [];

    async.forEach(results, function(group, asyncCallback) {
      // accumulates discovered groups
      if (typeof(stack) !== 'undefined') {
        if (!_.findWhere(stack, { cn: group.cn })) {
          stack.push(new Group({ dn: group.dn, cn: group.cn }));
        } else {
          // ignore groups already found
          return(asyncCallback());
        }

        _.each(stack,function(s) {
          if (!_.findWhere(groups, { cn: s.cn })) {
            groups.push(s);
          }
        });
      }

      log.debug('Adding group "%s" to %s"', group.dn, distinguishedName);
      groups.push(new Group({ dn: group.dn, cn: group.cn }));
      if (inspector.isGroupResult(group)) {
        // Get the groups that this group may be a member of.
        log.debug('Retrieving nested group membership for group "%s"', group.dn);
        getGroupMembershipForDN.call(self, group.dn, groups, function(err, nestedGroups) {
          if (err) {
            asyncCallback(err);
            return;
          }

          nestedGroups = _.map(nestedGroups, function(nestedGroup) {
            return(new Group({ dn: nestedGroup.dn, cn: nestedGroup.cn }));
          });
          log.debug('Group "%s" which is a member of group "%s" has %d nested group(s). Groups: %j',
            group.dn, distinguishedName, nestedGroups.length, nestedGroups);
          Array.prototype.push.apply(groups, nestedGroups);
          asyncCallback();
        });
      }
      else asyncCallback();
    }, function(err) {
      if (err) {
        callback(err);
        return;
      }

      // Remove the duplicates from the list.
      groups =  _.uniq(_.sortBy(groups, function(group) { return(group.cn || group.dn); }), true, function(group) {
        return(group.dn);
      });

      log.info('Group "%s" has %d group(s). Groups: %j', distinguishedName, groups.length, groups);
      callback(err, groups);
    });
  });
}

/**
 * For the specified filter, return the distinguishedName (dn) of all the matched entries.
 *
 * @private
 * @param {Object} [opts] Optional LDAP query string parameters to execute. { scope: '', filter: '', attributes: [ '', '', ... ], sizeLimit: 0, timelimit: 0 }
 * @params {Object|String} filter The LDAP filter to execute. Optionally a custom LDAP query object can be specified. { scope: '', filter: '', attributes: [ '', '', ... ], sizeLimit: 0, timelimit: 0 }
 * @param {Function} callback The callback to execute when completed. callback(err: {Object}, dns: {Array[String]})
 */
function getDistinguishedNames(opts, filter, callback) {
  var self = this;

  if (typeof(filter) === 'function') {
    callback = filter;
    filter = opts;
    opts = undefined;
  }
  if (typeof(opts) === 'string') {
    filter = opts;
    opts = undefined;
  }
  log.trace('getDistinguishedNames(%j,%j)', opts, filter);

  var opts = _.defaults(opts || {}, {
    filter: filter,
    scope: 'sub',
    attributes: [ 'distinguishedName' ]
  });
  search.call(self, opts, function(err, results) {
    if (err) {
      if (callback) callback(err);
      return;
    }

    // Extract just the DN from the results
    var dns =  _.map(results, function(result) {
      return(result.dn);
    });
    log.info('%d distinguishedName(s) found for LDAP query: "%s". Results: %j',
      results.length, string.ellipsis(opts.filter), results);
    callback(null, dns);
  });
}

/**
 * Gets the distinguished name for the specified user (userPrincipalName/email or sAMAccountName).
 *
 * @private
 * @param {Object} [opts] Optional LDAP query string parameters to execute. { scope: '', filter: '', attributes: [ '', '', ... ], sizeLimit: 0, timelimit: 0 }
 * @param {String} username The name of the username to retrieve the distinguishedName (dn).
 * @param {Function} callback The callback to execute when completed. callback(err: {Object}, dn: {String})
 */
function getUserDistinguishedName(opts, username, callback) {
  var self = this;

  if (typeof(username) === 'function') {
    callback = username;
    username = opts;
    opts = undefined;
  }
  log.trace('getDistinguishedName(%j,%s)', opts, username);

  // Already a dn?
  if (dn.isDistinguishedName(username)) {
    log.debug('"%s" is already a distinguishedName. NOT performing query.', groupName);
    callback(null, username);
    return;
  }

  getDistinguishedNames.call(self, opts, filter.getUserQueryFilter(username), function(err, dns) {
    if (err) {
      callback(err);
      return;
    }

    log.info('%d distinguishedName(s) found for user: "%s". Returning first dn: "%s"',
      (dns || []).length, username, (dns || [])[0]);
    callback(null, (dns || [])[0]);
  });
}

/**
 * Gets the distinguished name for the specified group (cn).
 *
 * @private
 * @param {Object} [opts] Optional LDAP query string parameters to execute. { scope: '', filter: '', attributes: [ '', '', ... ], sizeLimit: 0, timelimit: 0 }
 * @param {String} groupName The name of the group to retrieve the distinguishedName (dn).
 * @param {Function} callback The callback to execute when completed. callback(err: {Object}, dn: {String})
 */
function getGroupDistinguishedName(opts, groupName, callback) {
  var self = this;

  if (typeof(groupName) === 'function') {
    callback = groupName;
    groupName = opts;
    opts = undefined;
  }
  log.trace('getGroupDistinguishedName(%j,%s)', opts, groupName);

  // Already a dn?
  if (dn.isDistinguishedName(groupName)) {
    log.debug('"%s" is already a distinguishedName. NOT performing query.', groupName);
    callback(null, groupName);
    return;
  }

  getDistinguishedNames.call(self, opts, filter.getGroupQueryFilter(groupName), function(err, dns) {
    if (err) {
      callback(err);
      return;
    }

    log.info('%d distinguishedName(s) found for group "%s". Returning first dn: "%s"',
      (dns || []).length, groupName, (dns || [])[0]);
    callback(null, (dns || [])[0]);
  });
}


module.exports = [

};
